use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use tracing::error;

use crate::monarch_utils::monarch_download::download_image;
use crate::monarch_utils::monarch_fs::path_exists;

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct MonarchGame {
    pub name: String,
    pub id: String, // Monach ID, generated by monarch-launcher.com
    pub platform: String,
    pub platform_id: String,
    pub executable_path: String,
    pub thumbnail_path: String,
    pub launch_args: String,
    pub compatibility: String,
    pub store_page: String,

    #[serde(default)]
    pub install_dir: String,
}

impl MonarchGame {
    pub fn new(
        name: &str,
        id: i32,
        platform: &str,
        platform_id: &str,
        store_page: &str,
        exec_path: &str,
        thumbnail_path: &str,
    ) -> Self {
        Self {
            name: name.to_string(),
            id: id.to_string(),
            platform: platform.to_string(),
            platform_id: platform_id.to_string(),
            executable_path: exec_path.to_string(),
            thumbnail_path: thumbnail_path.to_string(),
            launch_args: String::new(),
            compatibility: String::new(),
            store_page: store_page.to_string(),
            install_dir: String::new(),
        }
    }

    /// Download thumbnail for MonarchGame
    pub async fn download_thumbnail(&self, url: String) {
        // TODO: Rewrite this function to query monarch-laucher.com
        // for images from igdb.com api.

        let path: PathBuf = PathBuf::from(&self.thumbnail_path);

        if path_exists(&path) {
            return;
        }

        /*
        * This is the previous solution that is faster to show the user the results
        * however it requires some sort of event to tell the frontend to refresh the
        * images.
        tokio::task::spawn(async move {
            if let Err(e) = download_image(&owned_url, &path).await {
                error!("monarchgame::download_thumbnail() -> {e}");
            }
        });
        */
        // Temporary solution for better image handling, which makes the
        // parsing of games slower.
        if let Err(e) = download_image(&url, &path).await {
            error!("monarchgame::download_thumbnail() -> {e}");
        }
    }

    /// Convert MonarchWebGame to MonarchGame
    pub fn from(other: &MonarchWebGame) -> Self {
        Self {
            name: other.name.to_string(),
            id: other.id.to_string(),
            platform: other.platform.to_string(),
            platform_id: other.platform_id.to_string(),
            executable_path: "".to_string(),
            thumbnail_path: "".to_string(),
            launch_args: "".to_string(),
            compatibility: "".to_string(),
            store_page: other.store_page.to_string(),
            install_dir: "".to_string(),
        }
    }
}

impl PartialEq for MonarchGame {
    fn eq(&self, other: &Self) -> bool {
        let platform = match self.platform.as_str() {
            "steamcmd" => "steam",
            _ => &self.platform,
        };

        let other_platform = match other.platform.as_str() {
            "steamcmd" => "steam",
            _ => &other.platform,
        };

        self.platform_id == other.platform_id && platform == other_platform
    }
}

impl Eq for MonarchGame {}

/// Struct representation of games returned from monarch-launcher.com
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct MonarchWebGame {
    pub name: String,
    pub id: String,
    pub igdb_id: i32,
    pub cover_url: String,
    pub artwork_url: String,
    pub summary: String,
    pub platform: String,
    pub platform_id: String,
    pub store_page: String,
}
